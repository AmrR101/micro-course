#set up:
#get interactive node: srun --pty -n 1 -p test -t 0-03:00 --mem 2000 /bin/bash
#cd to /n/holylfs/LABS/informatics/workshops/GTT_2018-03-06
#source setup_environment.sh
#make a working directory for yourself, e.g. mkdir tsackton
#cd tsackton
#cp -r ../data .
#ls

#BEGIN FASTX SECTION

#starting with some basic processing of fastq data; we'll use the seqtk toolkit

seqtk

#select 10000 reads from a fastq file

seqtk sample -s 42 data/Falb_COL2.1.fastq 10000 > Falb_COL2.1.subsample.fastq
wc -l Falb_COL2.1.subsample.fastq
seqtk sample -s 42 data/Falb_COL2.2.fastq 10000 > Falb_COL2.2.subsample.fastq
head -n 1 *.fastq
tail -n 4 *.fastq

#sample 10% of fasta file, convert to fasta

seqtk seq -s 42 -f 0.1 -A data/Falb_COL2.1.fastq 10000 >  Falb_COL2.1.subsample.fasta
seqtk seq -s 42 -f 0.1 -A data/Falb_COL2.2.fastq 10000 >  Falb_COL2.2.subsample.fasta
head *.fasta

#working with fasta data

seqtk comp data/Danio_rerio.GRCz10.fa 

#fair bit of stuff that is useless here, let's say we just want length + A T G C from the 'major' chromosomes:
#we'll pipe the output to grep to keep only lines that start with a numb, and cut to keep just the first 6 columns

seqtk comp data/Danio_rerio.GRCz10.fa | grep "^[0-9]" | cut -f1-6

#okay now we want to store it to a file, so we'll use > to redirect standard output to a file

seqtk comp data/Danio_rerio.GRCz10.fa | grep "^[0-9]" | cut -f1-6 > GRCz10_basecomp.txt

#brief intro to awk

#columns are stored as $1, $2, $3, etc
#entire line is $0

awk '{print $1, $2}' GRCz10_basecomp.txt

#can use if statements

awk '{if ($2 > 5e7) {print $1, $2}}' GRCz10_basecomp.txt

#can use pattern matching

awk '{if (/^1/) {print $1, $2}}' GRCz10_basecomp.txt

#can use variables

awk '{totbase=$3+$4+$5+$6; print $1, $2, totbase, $2-totbase}' GRCz10_basecomp.txt

#exercise; make an awk script that only prints lines with more than 75000 non-ATGC bases
#hint: define a variable that is nonATGC like so: awk '{nonATGC=$2-$3-$4-$5-$6; print nonATGC}' GRCz10_basecomp.txt
#then add an if statement instead of the print; and use print nonATGC, $0 to print the whole line plus the # non ATGC
#remember if statement is: if (test) { stuff to do }, so start by replacing print nonATGC with that
#answer: awk '{nonATGC=$2-$3-$4-$5-$6; if (nonATGC > 75000) {print nonATGC, $0}}' GRCz10_basecomp.txt

#let's say we want to extract only chr1 from this assembly
#I'll show you three ways to do this:

#seqtk 
echo "1" > seqtk_region.list #seqtk needs a file of regions to extract, either a list of names or a bed file
seqtk subseq data/Danio_rerio.GRCz10.fa -l 60 seqtk_region.list > Drerio_chr1.seqtk.fasta

#samtools
#your data needs to be indexed to use samtools; note I've already made an index in the data directory
samtools faidx data/Danio_rerio.GRCz10.fa 1 > Drerio_chr1.samtools.fasta 

#UCSC utilities
faOneRecord data/Danio_rerio.GRCz10.fa 1 > Drerio_chr1.ucsc.fasta #note there is also a faSomeRecords to get more than one record

#compare them
head Drerio_chr1.*.fasta

#EXERCISE: let's say that we want to 'un-softmask' this sequence by converting all the sequence letters to uppercase
#seqtk seq has an option to do this
#pick one of the methods above to extract chromosome 3 from the Drerio genome, but before writing the file pipe via seqtk seq to convert to uppercase
#call your output Drerio_chr3.fasta
#make sure you use the -l option to wrap the sequence across multiple lines
#check your work with head Drerio_chr3.fasta

#answer: samtools faidx data/Danio_rerio.GRCz10.fa 3 | seqtk seq -U -l 60 > Drerio_chr3.fasta

#name / lenght

samtools faidx data/dmel-all-chromosome-r6.20.fasta 
cp data/dmel-all-chromosome-r6.20.fasta.fai .
head dmel-all-chromosome-r6.20.fasta.fai 


#NAME	Name of this reference sequence
#LENGTH	Total length of this reference sequence, in bases
#OFFSET	Offset within the FASTA file of this sequence's first base
#LINEBASES	The number of bases on each line
#LINEWIDTH	The number of bytes in each line, including the newline

#how would you convert this to a file with just chr and length? hint: we used the tool earlier. answer:  cut -f1,2 dmel-all-chromosome-r6.20.fasta.fai > dmel-chr-lengths.txt

faSize -detailed data/dmel-all-chromosome-r6.20.fasta > dmel-chr-lengths-ucsc.txt

#you can also do this with awk


#so here is a very complicated awk command, putting this all together, to get lengths from a fasta file

#perl -p -e does some regular expression magic to clean it up

cat data/dmel-all-chromosome-r6.20.fasta | awk '{if(/^>/) {if (seqlen){print seqlen};printf $0" "; seqlen=0;next;} {seqlen += length($0)}}END{print seqlen}' | perl -p -e 's/>(\S+).*?(\d+)$/$1\t$2/' > dmel-chr-lengths-awk.txt

#Filter by length: three approaches
#custom UCSC tool

faFilter -minSize=500000 data/dmel-all-chromosome-r6.20.fasta dmel-500kb-chr.fa

#ugly awk 

#awk 'BEGIN{RS = ">"; OFS = ""} {if (length($0) > 500000) {print ">"$0}}' #data/dmel-all-chromosome-r6.20.fasta dmel_long_chrs > dmel-500kb-chr-3.fa

#exercise: first get lengths, then use seqtk subseq to extract those records only

awk '{if ($2 > 500000) { print $1 }}' dmel-chr-lengths-ucsc.txt > dmel_long_chrs
seqtk subseq data/dmel-all-chromosome-r6.20.fasta dmel_long_chrs > dmel-500kb-chr-2.fa


#final tips
#count records
grep -c "^>" *.fa

#look at first five headers
grep "^>" dmel-500kb-chr.fa | head -n 5

###END FASTA SECTIONgre

##BEGIN ANNOTATION SECTION

#two main annotation file formats: GFF files and BED files
#BED files represent base 1 through 100 as start = 0, end = 100 (0 based start, 1 based end)
#GFF represent base 1 through 100 as start = 1, end = 100

#GFF and BED also have different field structures: 

#GFF: seqname, source, feature, start, end, score, strand, frame, attribute
#BED: seqname, start, end, name, score, strand, thickStart, thickEnd, itermRgb, blockCount, blockSizes, blockStarts

#get all features in GFF

grep -v "^##" data/Homo_sapiens.GRCh38.91.gff3 | cut -f3 | sort | uniq -c

#extract just CDS

awk 'BEGIN {OFS = "\t"} {if ($3 == "CDS") {print}}' data/Homo_sapiens.GRCh38.91.gff3 > hg38_cds.gff3

#convert to bed:
#note this isn't trivial, because GFF records have start < end for + strand and start > end for - strand, but BED records always have start < end

awk 'BEGIN {OFS = "\t"} {if ($3 == "CDS") { print $1, $4-1, $5}}' data/Homo_sapiens.GRCh38.91.gff3 > hg38_cds.bed

#let's say we want to make a mask file to exclude all regions overlapping exons from a particular analysis
#if you look at the cds file, you will note that there are some intervals that overlap
#we want to clean this up
#to do so, we'll use the program bedtools, which we will return to in greater depth in a moment

bedtools

#bedtools merge sounds like what we want
#let's try it on hg38_cds.bed - a bit slow so for demonstration purposes will just use chrX
grep "^X" hg38_cds.bed | bedtools merge -i - > hg38_chrX_cds.bed

#we get an error saying we need sorted input

#so let's try again but add a bedtools sort command in the middle
grep "^X" hg38_cds.bed | bedtools sort -i - | bedtools merge -i - > hg38_chrX_cds.bed

#now we have a bed file of all CDS regions on the X chromosome

#there is a file, dmel-all-no-analysis-r6.20.gff in the data directory. Write a script to convert all genes in this file to beds, one per gene
#exercise: 
#answer:
grep -v "^#" data/dmel-all-no-analysis-r6.20.gff | awk 'BEGIN {OFS = "\t"} {if ($3 == "gene") { print $1, $4-1, $5 }}' > dmel-genes.bed

#what if we want to add a name field?
grep -v "^#" data/dmel-all-no-analysis-r6.20.gff | awk 'BEGIN {OFS = "\t"} {if ($3 == "gene") { print $1, $4-1, $5 , $9}}' > dmel-genes-named.bed

#names are pretty ugly, let's use a quick trick to keep just the ID=FBgn part
cut -f1 -d ";" dmel-genes-named.bed > dmel-genes-named-better.bed

#still not great, don't like the ID=
#we can use multiple field separators in awk
grep -v "^#" data/dmel-all-no-analysis-r6.20.gff | awk 'BEGIN {FS = "=|;|\t"; OFS="\t"} {if ($3 == "gene") { print $1, $4-1, $5 , $10}}' > dmel-genes-named-best.bed

#check
head dmel-genes-named*.bed
wc -l dmel-genes-named*.bed

#get just genes on chrX
grep "^X" dmel-genes-named-best.bed > dmel-genes-chrX.bed

#pick 10 at random
bedtools sample -i dmel-genes-chrX.bed -n 10 > dmel-10genes.bed

#use bedtools getfasta to extract fasta seqs for these 10 genes
bedtools getfasta -fi data/dmel-all-chromosome-r6.20.fasta -bed dmel-10genes.bed -name > dmel-10genes.fasta

#okay, here is an exercise in piping
#using a single command, get 10 random exons from chromosome 2L in Drosophila
#don't bother retaining the name, but do reverse complement those on the negative strain
#note that most bedtools commands can take a GFF as input, so you don't need to convert to bedf
#remember that you will need to use - when you pipe between commands
#take it step by step, and feel free to test using temporary files, but be sure in the end you have a single one-liner that works
#you will need to use awk to at least get CDS regions; the needed command is awk 'BEGIN {OFS = "\t"} {if ($3 == "CDS") {print $0}}' -- this will retain GFF format (you can modify if you want to convert to BED at this step

grep "^2L" data/dmel-all-no-analysis-r6.20.gff | awk 'BEGIN {OFS = "\t"} {if ($3 == "CDS") {print $0}}' | bedtools sample -i - -n 10 | bedtools getfasta -fi data/dmel-all-chromosome-r6.20.fasta -bed - -s > dmel-2L-cds.fa   

#note: you can also do a lot of this with the UCSC tools gff3ToGenePred and genePredToBed but in interest of time we are not covering these options (see also genePredFilter, and randomLines for something like bedtools sample)

#another UCSC tool worth knowing about that we won't use today: subColumn which can help with chromosome renaming issues

#okay, now let's explore some genome arithmetic type questions:

#Bedtools has a fairly comprehensive command line help, and also pretty good documentation [online](http://bedtools.readthedocs.org/en/latest/). Let's first just see what we can do by typing `bedtools` on the command line, which will give you a list of the sub-programs we can run. 

#The first thing we'll do figure out what the closest gene is to each enhancer in our two enhancer bed files. **Exercise**: Scroll through the list of options and figure out what the best sub-command would be to do this.

#To get help on a specific command, type `bedtools closest -h`

#You'll see that for many commands, bedtools works by taking a 'query' bed file (specified with the -a option) and comparing it to a 'target' bed file (specified with the -b option). Although for some tools it doesn't matter which you put as -a and which as -b, in some cases it does matter so it is worth thinking through a bit.

#**Exercise**: to find which gene is closest to each enhancer in a given BED file, what should be specify as -a and what as -b?

#Answer:

bedtools closest -a data/human_enhancers.bed -b data/ucscGenes.bed | head

#**Exercise**: in this case, does bedtools output a bed file? How could we convert this to a proper bed file, where we keep the score but replace the names (HSE####) with the closest gene? (Hint: think about UNIX tools)

#Answer: bedtools closest -a data/human_enhancers.bed -b data/ucscGenes.bed | awk -v OFS='\t' '{print $1, $2, $3, $9, $5}' | head

#Okay, now let's make a file that contains the closest gene for each of the human-specific enhancers, in proper bed format, but we'll add two additional options (refer back to bedtools closest -h for the full option list): -d to give us the distance to the nearest gene, which we'll put in the 'score' field of the output bed file, and -t "first" means that if there are ties, we'll just keep one (so that we have each enhancer assigned to a single gene). 

bedtools closest -a data/human_enhancers.bed -b data/ucscGenes.bed -d -t "first" | awk -v OFS='\t' '{print $1, $2, $3, $9, $10}' > hse_closest_genes.bed

#**Exercise**: What do we need to change to get the equivalent set but for the common enhancers?

#Answer: The input file name for bed file 'A', the output file name, and the field numbers for the gene and score.

bedtools closest -a data/common_enhancers.bed -b data/ucscGenes.bed -d -t "first" | awk -v OFS='\t' '{print $1, $2, $3, $7, $8}' > ce_closest_genes.bed

#Another common task is finding overlaps between two sets of intervals. For example, we might want to know which of our enhancers identified in neural crest cells are shared with enhancers identified in some other cell type. In your directory you should see another bed file, H1-hESC-H3K27Ac.bed, which has H3K27Ac peaks from human embryonic stem cells. We'll use bedtools to get the overlaps between this file and each of our enhancer files. 

#The tool we'll use is intersect. Let's start by looking at the options: ```bedtools intersect -h```

#The output of this can be a bit complicated, so let's start by just looking at a few things:

bedtools intersect -a data/human_enhancers.bed -b data/H1-hESC-H3K27Ac.bed | head -n 3

#What are we seeing here?

bedtools intersect -a data/human_enhancers.bed -b data/H1-hESC-H3K27Ac.bed -wa | head -n 3

bedtools intersect -a data/human_enhancers.bed -b data/H1-hESC-H3K27Ac.bed -wb | head -n 3

bedtools intersect -a data/human_enhancers.bed -b data/H1-hESC-H3K27Ac.bed -loj | head -n 3

bedtools intersect -a data/human_enhancers.bed -b data/H1-hESC-H3K27Ac.bed -wao | head -n 3


#And now?

#**Exercise**: What if we wanted to get a new bed file with only the neural crest specific enhancers? That is, we want to filter out anything that overlaps (by even 1 bp) with a H3K27Ac peak in stem cells. Look at the bedtools intersect -h output and see if you can figure out what option to use to do this.

#Answer: bedtools intersect -a data/human_enhancers.bed -b data/H1-hESC-H3K27Ac.bed -v > human_nconly_enhancers.bed

#Finally, we might want to generate a file where, for each neural crest enhancer in our list, we get the number of H1-hESC-H3K27Ac peaks it overlaps with. We'll use the `-c` option in bedtools for this. We'll also restrict overlaps to a reciprocal 20% -- so each feature in A has to overlap 25% of B, and vice versa, to count as an overlap. 


bedtools intersect -a data/human_enhancers.bed -b data/H1-hESC-H3K27Ac.bed -f 0.20 -r -c > human_overlaps.txt

#Now let's do the same thing with common enhancers:

bedtools intersect -a data/common_enhancers.bed -b data/H1-hESC-H3K27Ac.bed -f 0.20 -r -c > common_overlaps.txt

#okay, let's do one more thing that will introduce a couple of additional tools

#let's say we wanted to shuffle enhancers to random locations in the genome, but exclude them from known genes and introns (just allow them to fall in intergenic regions
#biologically this is not completely realistic, since enhancers can be in introns, but it will illustrate the procedure

#we might want to do this to, for example, ask whether enhancers are closer to genes than might be expected by chance

#first we need to make a bed file of regions to place elements

bedtools complement -i data/ucscGenes.bed -g data/hg19.genome > hg19_intergenic.bed

#error, due to sorting differences

bedtools sort -i data/ucscGenes.bed -faidx data/hg19.genome | bedtools complement -i - -g data/hg19.genome > hg19_intergenic.bed

#let's make sure we sort 

bedtools shuffle -incl hg19_intergenic.bed -i data/common_enhancers.bed -noOverlapping -g data/hg19.genome > common_enhancers_random.bed

#Exercise: are the common enhancers are closer to genes than random ones, first excluding common enhancers that overlap genes

#first step is to make a new common_enhancers.bed file that removes any element overlapping a gene
#next step is to use bedtools closest on both the new common enhancers file and the common enhancers random file to get the distance to the closest gene (uscsGenes.bed)
#then use awk calculate the column mean: awk '{ sum += $2 } END { if (NR > 0) print sum / NR }' (but you'll need to change $2 to the correct column

bedtools intersect -a data/common_enhancers.bed -b data/ucscGenes.bed -v -wa > common_enhancers_clean.bed
bedtools closest -a common_enhancers_clean.bed -b data/ucscGenes.bed -d -t first | awk '{sum += $8} END { if (NR > 0) print sum / NR}'
bedtools sort -i common_enhancers_random.bed | bedtools closest -a - -b data/ucscGenes.bed -d -t first | awk '{sum += $8} END { if (NR > 0) print sum / NR}'

#so yes, real enhancers seem to be way closer to genes that expected by chance..not surprisingly

### END BED / GFF ###


#BEGIN SAM/BAM ###

#finally, we will just briefly introduce some sam/bam processing

#we've already seen how to use samtools faidx to index a file
#however lots of other things you can do with samtools

samtools

#convert to sam

samtools view data/Falb_COL2.final.bam | head
samtools view -b data/Falb_COL2.final.sam > Falb_COL2.new.bam 

#can also use -L to get only reads overlapping a particular region

#convert to bed
#need to sort bam by query, not position
#we'll also use samtools view to remove reads that are not properly paired, and fixmate to remove unmapped and secondary alignments from paired reads
samtools view -b -f 0x2 data/Falb_COL2.final.bam | samtools sort -n - | samtools fixmate -r - Falb_COL2.querysort.bam
bedtools bamtobed -i Falb_COL2.querysort.bam -bedpe > Falb_COL2.bed

samtools depth data/Falb_COL2.final.bam > Falb_COL2.depth
bedtools genomecov -ibam data/Falb_COL2.final.bam -bga -pc -g data/Falb_region.genome > Falb_COL2_depth.bedGraph

#bedgraphs can be manipulated with UCSC tools
bedGraphToBigWig Falb_COL2_depth.bedGraph data/Falb_region.genome Falb_COL2_depth.bw
bigWigInfo Falb_COL2_depth.bw 
bigWigSummary Falb_COL2_depth.bw 5:21000000-23000000 0 2000001 20

#see also: bigWigAverageOverBed 

